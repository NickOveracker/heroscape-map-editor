/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF } from '@react-three/drei'
import { HexTerrain, Pieces } from '../../types'
import { hexTerrainColor } from '../maphex/hexColors'
import { decodePieceID } from '../../utils/map-utils'
import { piecesSoFar } from '../../data/pieces'
import usePieceHoverState from '../../hooks/usePieceHoverState'
import useBoundStore from '../../store/store'
import React, { PropsWithChildren } from 'react'
import { isFluidTerrainHex } from '../../utils/board-utils'
import { ThreeEvent } from '@react-three/fiber'

export default function LandSubterrain({ pid }: { pid: string }) {
  const {
    pieceID,
    // altitude,
    // rotation,
    // boardHexID,
    // pieceCoords
  } = decodePieceID(pid)
  const {
    // isHovered, // cannot use this, this is for obstacles
    onPointerEnterPID,
    onPointerOut,
  } = usePieceHoverState()
  const hoveredPieceID = useBoundStore(s => s.hoveredPieceID)
  const selectedPieceID = useBoundStore(s => s.selectedPieceID)
  const isSelected = selectedPieceID === pid
  const isHovered = hoveredPieceID === pid
  const pieceTerrain = piecesSoFar[pieceID].terrain
  const isDirtSubterrain =
    pieceTerrain === HexTerrain.grass ||
    pieceTerrain === HexTerrain.sand ||
    pieceTerrain === HexTerrain.rock
  const baseColor = isDirtSubterrain
    ? hexTerrainColor[HexTerrain.dirt]
    : hexTerrainColor[pieceTerrain]
  const [color, setColor] = React.useState('red')
  const regex = /\d+/g;

  let pieceSize = pieceID.match(regex)?.[0] ?? '';
  const isHighlighted = isHovered || isSelected
  if (pieceSize === '7' && pieceID === Pieces.wallWalk7) {
    pieceSize = '7B'
  }
  // update color when piece is hovered/selected
  React.useEffect(() => {
    if (isHighlighted) {
      setColor('yellow')
    } else {
      setColor(baseColor)
    }
  }, [baseColor, isHighlighted])
  const toggleSelectedPieceID = useBoundStore(s => s.toggleSelectedPieceID)
  const onPointerUp = (event: ThreeEvent<PointerEvent>) => {
    event.stopPropagation() // prevent pass through
    // Early out right clicks(event.button=2), middle mouse clicks(1)
    if (event.button !== 0) {
      return
    }
    toggleSelectedPieceID(isSelected ? '' : pid)
  }
  const getMesh = () => {
    switch (pieceSize) {
      case '1':
        return (
          <Subterrain1 >
            {isFluidTerrainHex(pieceTerrain) ? <meshLambertMaterial color={color} transparent opacity={0.85} /> : <meshMatcapMaterial color={color} />}
          </Subterrain1>
        )
      case '2':
        return (
          <Subterrain2 >
            {isFluidTerrainHex(pieceTerrain) ? <meshLambertMaterial color={color} transparent opacity={0.85} /> : <meshMatcapMaterial color={color} />}
          </Subterrain2>
        )
      case '3':
        return (
          <Subterrain3 >
            {isFluidTerrainHex(pieceTerrain) ? <meshLambertMaterial color={color} transparent opacity={0.85} /> : <meshMatcapMaterial color={color} />}
          </Subterrain3>
        )
      case '4':
        return (
          <Subterrain4 >
            {isFluidTerrainHex(pieceTerrain) ? <meshLambertMaterial color={color} transparent opacity={0.85} /> : <meshMatcapMaterial color={color} />}
          </Subterrain4>
        )
      case '5':
        return (
          <group
            onPointerEnter={(e) => onPointerEnterPID(e, pid)
            }
            onPointerOut={onPointerOut}
          >
            <Subterrain5 >
              {isFluidTerrainHex(pieceTerrain) ? <meshLambertMaterial color={color} transparent opacity={0.85} /> : <meshMatcapMaterial color={color} />}
            </Subterrain5>
          </group >
        )
      case '6':
        return (
          <Subterrain6 >
            {isFluidTerrainHex(pieceTerrain) ? <meshLambertMaterial color={color} transparent opacity={0.85} /> : <meshMatcapMaterial color={color} />}
          </Subterrain6>
        )
      case '7B':
        return (
          <Subterrain7B >
            {isFluidTerrainHex(pieceTerrain) ? <meshLambertMaterial color={color} transparent opacity={0.85} /> : <meshMatcapMaterial color={color} />}
          </Subterrain7B>
        )
      case '7':
        return (
          <Subterrain7 >
            {isFluidTerrainHex(pieceTerrain) ? <meshLambertMaterial color={color} transparent opacity={0.85} /> : <meshMatcapMaterial color={color} />}
          </Subterrain7>
        )
      case '9':
        return (
          <Subterrain9 >
            {isFluidTerrainHex(pieceTerrain) ? <meshLambertMaterial color={color} transparent opacity={0.85} /> : <meshMatcapMaterial color={color} />}
          </Subterrain9>
        )
      case '24':
        return (
          <Subterrain24 >
            {isFluidTerrainHex(pieceTerrain) ? <meshLambertMaterial color={color} transparent opacity={0.85} /> : <meshMatcapMaterial color={color} />}
          </Subterrain24>
        )
      default:
        return null
    }
  }
  return (
    <>
      <group
        onPointerEnter={(e) => onPointerEnterPID(e, pid)}
        onPointerOut={onPointerOut}
        onPointerUp={onPointerUp}
      >
        {getMesh()}
      </group>
    </>
  )
}

export function Subterrain24({ children }: PropsWithChildren) {
  const { nodes } = useGLTF('/subterrain_24.glb') as any
  return (
    <mesh
      geometry={nodes.Subterrain_24.geometry}
    >
      {children}
    </mesh>
  )
}
useGLTF.preload('/subterrain_24.glb')

export function Subterrain9({ children }: PropsWithChildren) {
  const { nodes } = useGLTF('/subterrain_9.glb') as any
  return (
    <mesh
      geometry={nodes['Subterrain-9'].geometry}
    >
      {children}
    </mesh>
  )
}
useGLTF.preload('/subterrain_9.glb')

export function Subterrain7B({ children }: PropsWithChildren) {
  const { nodes } = useGLTF('/subterrain_7B.glb') as any
  return (
    <mesh
      geometry={nodes['Subterrain-7B'].geometry}
    >
      {children}
    </mesh>
  )
}
useGLTF.preload('/subterrain_7B.glb')

export function Subterrain7({ children }: PropsWithChildren) {
  const { nodes } = useGLTF('/subterrain_7.glb') as any
  return (
    <mesh
      geometry={nodes.Subterrain_7.geometry}
    >
      {children}
    </mesh>
  )
}
useGLTF.preload('/subterrain_7.glb')


export function Subterrain6({ children }: PropsWithChildren) {
  const { nodes } = useGLTF('/subterrain_6.glb') as any
  return (
    <mesh
      geometry={nodes.Subterrain_6.geometry}
    >
      {children}
    </mesh>
  )
}
useGLTF.preload('/subterrain_6.glb')

export function Subterrain5({ children }: PropsWithChildren) {
  const { nodes } = useGLTF('/subterrain_5.glb') as any
  return (
    <mesh
      geometry={nodes.Subterrain_5.geometry}
    >
      {children}
    </mesh>
  )
}
useGLTF.preload('/subterrain_5.glb')

export function Subterrain4({ children }: PropsWithChildren) {
  const { nodes } = useGLTF('/subterrain_4.glb') as any
  return (
    <mesh
      geometry={nodes.Subterrain_4.geometry}
    >
      {children}
    </mesh>
  )
}
useGLTF.preload('/subterrain_4.glb')

export function Subterrain3({ children }: PropsWithChildren) {
  const { nodes } = useGLTF('/subterrain_3.glb') as any
  return (
    <mesh
      geometry={nodes.Subterrain_3.geometry}
    >
      {children}
    </mesh>
  )
}
useGLTF.preload('/subterrain_3.glb')

export function Subterrain2({ children }: PropsWithChildren) {
  const { nodes } = useGLTF('/subterrain_2.glb') as any
  return (
    <mesh
      geometry={nodes.Subterrain_2.geometry}
    >
      {children}
    </mesh>
  )
}
useGLTF.preload('/subterrain_2.glb')

export function Subterrain1({ children }: PropsWithChildren) {
  const { nodes } = useGLTF('/subterrain_1.glb') as any
  return (
    <mesh
      geometry={nodes.Subterrain_1.geometry}
    >
      {children}
    </mesh>
  )
}
useGLTF.preload('/subterrain_1.glb')